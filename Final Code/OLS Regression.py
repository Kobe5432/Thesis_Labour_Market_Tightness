from statsmodels.stats.outliers_influence import variance_inflation_factor
import pandas as pd
import statsmodels.api as sm
import matplotlib.pyplot as plt
from statsmodels.nonparametric.smoothers_lowess import lowess
import numpy as np

plt.rcParams["font.family"] = "Arial"

model_colors = {
    'Model 1': '#156082',   # blue
    'Model 2': '#FFC000',  # yellow
    'Model 3': '#E97132',  # orange
    'Model 4': '#4EA72E'  # green
}

model_alphas = [1.0, 0.7, 0.7, 1.0] 
model_linestyles = ['--',':',':','--']

def main(start_year=None, end_year=None, show_plots=True, selected_sections=None):
    # Load your dataset
    print("Loading data...")
    data = pd.read_excel(r"filepath")
    print("Data loaded successfully!")

    # Ensure 'Year' column is correctly interpreted as datetime or integer
    print("Converting 'Year' column to appropriate format...")
    if not pd.api.types.is_numeric_dtype(data['Year']):
        data['Year'] = pd.to_datetime(data['Year'], format='%Y').dt.year

    # Filter data based on the specified range of years
    if start_year is not None and end_year is not None:
        data = data[(data['Year'] >= start_year) & (data['Year'] <= end_year)]

    print("Length of filtered data:", len(data))

    # Calculate necessary columns
    data['wage_inflation'] = data['LCI inflation']
    data['ma_wage_inflation'] = data.groupby('Economic section')['wage_inflation'].rolling(window=2).mean().reset_index(level=0, drop=True)
    data['productivity_growth'] = data['productivity growth per person']
    data['ma_productivity_inflation'] = data.groupby('Economic section')['productivity_growth'].rolling(window=2).mean().reset_index(level=0, drop=True)
    data['lagged_ma_productivity_inflation'] = data.groupby('Economic section')['ma_productivity_inflation'].shift(3)
    data['job_vacancy_rate'] = data['Job vacancy rate']
    data['ma_job_vacancy_rate'] = data.groupby('Economic section')['job_vacancy_rate'].rolling(window=2).mean().reset_index(level=0, drop=True)
    data['lagged_ma_job_vacancy_rate'] = data.groupby('Economic section')['ma_job_vacancy_rate'].shift(2)
    data['lagged_inflation_expectations'] = data.groupby('Economic section')['Backward-looking inflation'].shift(0)

    # Define predictors for each model
    model_1_predictors = ['lagged_ma_job_vacancy_rate']
    model_2_predictors = ['lagged_inflation_expectations']
    model_3_predictors = ['lagged_inflation_expectations', 'lagged_ma_productivity_inflation']
    model_4_predictors = ['lagged_inflation_expectations', 'lagged_ma_productivity_inflation', 'lagged_ma_job_vacancy_rate']
    all_predictors = [model_1_predictors, model_2_predictors, model_3_predictors, model_4_predictors]

    # Drop rows with missing values generated by lagging
    data = data.dropna(subset=model_4_predictors + ['ma_wage_inflation'])

    # Filter data based on selected sections if provided
    if selected_sections is not None:
        data = data[data['Economic section'].isin(selected_sections)]
        data['Year'] = data['Year'].astype(int)
        
    # Create period labels
    data['Period_Label'] = data['Year'].astype(str).str[-2:] + '_' + data['Period']


    # DataFrame to store summary
    summary = pd.DataFrame(columns=[
        'Section', 
        'Model', 
        'Variable', 
        'Coefficient', 
        'Standard Error', 
        't-value', 
        'p-value',
        'R-squared',
        'Adjusted R-squared',
        'Prob (F-statistic)',
        'Number of Observations'
    ])

    # Iterate over each economic section
    for section in data['Economic section'].unique():
        section_data = data[data['Economic section'] == section]
        x_labels = section_data['Period_Label'].tolist()
        
        print(f"Processing section: {section}, Data length: {len(section_data)}")
        
        # Define the dependent variable
        y = section_data['ma_wage_inflation']
        y_ma = y.rolling(window=1).mean()

        predictions = {}  # Dictionary to store predictions for each model

        for i in range(1, len(all_predictors) + 1):
            summary_data = []
            current_predictors = all_predictors[i-1]
            X = section_data[current_predictors]
            X = sm.add_constant(X)

            # Align the indices of y_ma and X by dropping NaNs
            aligned_data = pd.concat([y_ma, X], axis=1).dropna()
            y_ma_aligned = aligned_data['ma_wage_inflation']
            X_aligned = aligned_data.drop(columns='ma_wage_inflation')

            print(f"Model {i}, Predictors: {current_predictors}")

            # Fit the regression model
            model = sm.OLS(y_ma_aligned, X_aligned).fit()
        
            # Store predictions for the current model
            section_data.loc[aligned_data.index, f'predicted_wage_inflation_model_{i}'] = model.predict(X_aligned)
            predictions[f'Model {i}'] = section_data[f'predicted_wage_inflation_model_{i}']

            # Store coefficients, standard errors, t-values, and p-values in the summary DataFrame
            for var in model.params.index:
                summary_data.append({
                    'Section': section,
                    'Model': f'Model {i}',
                    'Variable': var,
                    'Coefficient': model.params[var],
                    'Standard Error': model.bse[var],
                    't-value': model.tvalues[var],
                    'p-value': model.pvalues[var],
                    'R-squared': model.rsquared,
                    'Adjusted R-squared': model.rsquared_adj,
                    'Prob (F-statistic)': model.f_pvalue,
                    'Number of Observations': model.nobs
                })

            summary = pd.concat([summary, pd.DataFrame(summary_data)], ignore_index=True)
        
        print(f"Length of summary after section {section}: {len(summary)}")

        # Plot actual vs predicted values with confidence intervals if show_plots is True
        if show_plots:
            plt.figure(figsize=(12, 8))
            plt.plot(x_labels, y_ma, label='Actual Wage Inflation', color='red', alpha=0.8)
            
            # Iterate over the models and plot each with the specified colors
            for i, (model_name, color) in enumerate(model_colors.items(), 1):
                if i > len(all_predictors):
                    break
                
                plt.plot(x_labels, predictions[f'Model {i}'], 
                         label=f'Predicted Wage Inflation ({i})', color=color, 
                         linestyle=model_linestyles[i-1], alpha=model_alphas[i-1])
                
            plt.ylabel('Wage Inflation (%)', fontsize=12)
            plt.title(f'{section}', fontsize=14)
            plt.legend(loc='upper left', fontsize=12)

            # Set x-ticks and x-tick labels
            ax = plt.gca()  # Get the current Axes instance
            ax.set_xticks(range(len(x_labels)))

            # Modify x_labels to only show labels for the first quarter (e.g., 'Q1')
            modified_labels = [label if 'Q4' in label else '' for label in x_labels]

            # Set these modified labels as the x-tick labels
            ax.set_xticklabels(modified_labels, rotation=20, ha='right', fontsize=12)

            plt.yticks(fontsize=12)
            plt.grid(axis='y', alpha=0.3)
            plt.show()

    # Write summary to a CSV file
    summary.to_excel('regression_summary.xlsx', index=False)

############# SET #############
if __name__ == "__main__":
    # set to None if all sections must be plotted
    selected_sections = ['Construction', 'Information and communication', 'Professional, scientific and technical activities', 'Financial and insurance activities', 'Wholesale and retail trade; repair of motor vehicles and motorcycles']  # Replace with actual section names
    main(start_year=2011, end_year=2023, show_plots=True, selected_sections=selected_sections)
